1. 适用条件：

   寻找**左/右**侧比该index位置**大/小**的位置

2. 其他情况
   - 重复数字怎么处理

3. 实现方式：

   - 数组

   - stack

     区别：Java 的`java.util.Stack`类 **继承自`Vector`**（一个线程安全的动态数组）利用**`synchronized`**同步锁，效率较低

4. 知识点

   - Deque中的push相当于addFirst
   - Arrays.*fill*(*height*, 0, col, 0); `Arrays.fill(height, 0, m, 0)` 是 **Java 中 `java.util.Arrays` 类的数组填充方法**，作用是：将数组 `height` 中**从索引 0（包含）到索引 m（不包含）** 的所有元素，全部赋值为 `0`。

   

```java
子数组的最小值之和
// 测试链接 : https://leetcode.cn/problems/sum-of-subarray-minimums/=
* 然后统计出当前为为最小值的开头可能性和结尾可能性cur - left,right - cur
* */

/*
* 左神思路：
* 基本思路相同，关键在于如何找到以cur为最下的最左侧和最右侧
* 我的思路是以当前元素利用两个单调栈分别找到其最左和最右	
* 左神是一个单调栈大压小的栈，i为当前元素，cur为其淘汰后的栈顶元素，left为cur下一个元素
* 左神这个栈会存在未清空的清空，此时右侧为length + 1
* */
```

```java

```

